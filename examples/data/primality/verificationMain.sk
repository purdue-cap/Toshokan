
pragma options "--bnd-inbits 3 --bnd-unroll-amnt 8 --bnd-cbits 3 ";

int cap = {{cap_logs}};
int logged = {{n_logs}};
int[cap] iarr = { {{expand-array logs_i.[0]}} };
int[cap] rarr = { {{expand-array logs_r}} };


int sqrt(int i){
    for (int idx = 0; idx < logged; idx ++) {
        if (iarr[idx] == i) {
            return rarr[idx];
        }
    }
    return uninterpreted_sqrt(i);
}

int uninterpreted_sqrt(int i);

bit condition(int p, int i) {
    int factor = {{holes.[0]}}%2;
    int addor = {{holes.[1]}}%2;
    int arg;
    if ({{holes.[2]}}) {
        arg = factor*p + addor;
    } else {
        arg = factor*p - addor;
    }
    int rtn = sqrt(arg);

    if ({{holes.[3]}}) {
        return i < rtn;
    }
    if ({{holes.[4]}}) {
        return i > rtn;
    }
    if ({{holes.[5]}}) {
        return i <= rtn;
    }
    if ({{holes.[6]}}) {
        return i >= rtn;
    }
}

bit primality(int p) {
	if(p<=1) return 0;
	for(int i=2;condition(p, i);i++){
		if(p%i == 0) return 0;
	}
	return 1;
}

bit primality_spec(int p){
	if(p<=1) return 0;
	for(int i=2;i<p;i++){
		if(p%i == 0) return 0;
	}
	return 1;
}

harness void main(int p) {
    assume {{expand-points verify_points.[0] "p"}};
    assert primality(p) == primality_spec(p);
}
