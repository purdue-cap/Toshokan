pragma options "--bnd-inbits 5 --bnd-unroll-amnt 5 --bnd-cbits 3 --slv-nativeints --slv-parallel --slv-p-cpus 4 --slv-randassign --slv-randdegree 5";
int K=2;

int cap = {{get-cap-logs (subtree logs "ANONYMOUS::sqrt_real") n_unknowns}};
int logged = {{get-n-logs (subtree logs "ANONYMOUS::sqrt_real") }};
int count = 0;
int index(int i);
bit match(int i);

int[cap] iarr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sqrt_real") 0 n_unknowns}} };
int[cap] rarr = { {{expand-to-rtn-array (subtree logs "ANONYMOUS::sqrt_real") n_unknowns}} };


int[{{n_unknowns}}] unknown = ??;
int used_unknown = 0;

generator int sqrt(int i){
	if (match(count)) {
		int idx = index(count);
		assume 0 <= idx && idx < logged && iarr[idx] == i;
	} else {
		{{#for-cap-logs (subtree logs "ANONYMOUS::sqrt_real") n_unknowns}}
		assume ({{@index}} >= logged) || ( iarr[{{@index}}] != i);{{/for-cap-logs}}
	}
    return sqrt_real(i);
}

int sqrt_real(int i) {
	if (match(count)) {
		int idx = index(count);
		count ++;
		return rarr[idx];
	} else {
		assert logged < cap;
		int val = unknown[used_unknown];
		used_unknown++;
		iarr[logged] = i;
		rarr[logged] = val;
		logged ++;
		count ++;
		return val;
	}
}


int twokroot(int num,int k){
	if(num==0) return 0;
    if (num==1) return 1;
    for(int i=2;i<num;i++){
		int kpow=i;
		for(int j=0;j<k;j++){
			kpow = (kpow*kpow);
			if(kpow > num) return i-1;
		}
		
    }
    return 1;
}


harness void main(int x){//find 2^k th root of x
    {{expand-points-to-assume c_e_s.[0] "x"}}
	//k=0; x=1;
	int k=K;
	if(k==0 || x==0) return;
	
	int val = x;
	for(int i=??;{| i (< | > | <= | >=) {| (??)*k (+|-) (??) |} |};i++){
		if(val != 1 && val != 0){
			val = sqrt(val);
		}
	}
	assert(val !=0);
	assert(val == twokroot(x,k));
}
