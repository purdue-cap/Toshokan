pragma options "--bnd-inbits 4 --bnd-inline-amnt 2 --bnd-unroll-amnt 16 --bnd-cbits 3 ";

int cap = {{cap_logs}};
int logged = {{n_logs}};
int[cap] iarr = { {{expand-partial-array logs_i.[0] n_unknowns}} };
int[cap] rarr = { {{expand-partial-array logs_r n_unknowns}} };


int[{{n_unknowns}}] unknown = ??;
int used_unknown = 0;

int log(int i){
    for (int idx = 0; idx < logged; idx ++) {
        if (iarr[idx] == i) {
            return rarr[idx];
        }
    }
    int val = unknown[used_unknown];
    used_unknown++;
    if (logged < cap) {
        iarr[logged] = i;
        rarr[logged] = val;
        logged ++;
    }
    return val;
}

int pow(int a, int b){
    int result = 1;
    for(int i=0; i<b; i++)
       result = result * a;
    return result;
}

int N = 5;

harness void closestTwoPower(int[N] a){
    assume {{expand-x-d-points c_e_s "a[0]" "a[1]" "a[2]" "a[3]" "a[4]"}};

	int[N] b;

	int result = 0;
	int bound_choice = ??%3;
	int bound = 0;
	if (bound_choice == 0) {
		bound = N;
	} else if (bound_choice == 1) {
		bound = N-1;
	} else if (bound_choice == 2) {
		bound = N-2;
	}
	for(int i=??; i<bound; i++){
	int exp = log(a[i]);
	int result_choice = ??%3;
	if (result_choice == 0)	 {
		b[i] = exp;
	} else if (result_choice == 1) {
		b[i] = exp + 1;
	} else if (result_choice == 2) {
		b[i] = exp - 1;
	}
	result += pow(2, b[i]);
	}	
	
	for(int i=0; i<N ; i++){
	int r = 1;
	for(int j=0; j<b[i]; j++){
	 r = r * 2;
	 }	  
	 if(b[i]>0) assert r < a[i];

	 }	  

}