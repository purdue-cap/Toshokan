pragma options "--bnd-inbits 5 --bnd-unroll-amnt 5 --bnd-cbits 3 --slv-nativeints";
int K=2;

int cap = {{cap_logs}};
int logged = {{n_logs}};
int[cap] iarr = { {{expand-partial-array logs_i.[0] n_unknowns}} };
int[cap] rarr = { {{expand-partial-array logs_r n_unknowns}} };


int[{{n_unknowns}}] unknown = ??;
int used_unknown = 0;

generator int sqrt(int i){
    for (int idx = 0; idx < logged; idx ++) {
        if (iarr[idx] == i) {
            return rarr[idx];
        }
    }
    int val = unknown[used_unknown];
    used_unknown++;
    if (logged < cap) {
        iarr[logged] = i;
        rarr[logged] = val;
        logged ++;
    }
    return val;
}


int twokroot(int num,int k){
	if(k==2){
		if(num <1) return 0;
		else if(num < 16) return 1;
		else return 2;
	}
	else{
		if(num <1) return 0;
		else return 1;
	}
}

bit condition(int i, int k) {
    int factor = ??;
    int addor = ??;
    int comparator;
    if (??) {
        comparator = factor*k + addor;
    } else {
        comparator = factor*k - addor;
    }

    int comp = ??%4;

    if (comp == 0) {
        return i < comparator;
    }
    if (comp == 1) {
        return i > comparator;
    }
    if (comp == 2) {
        return i <= comparator;
    }
    if (comp == 3) {
        return i >= comparator;
    }
    return false;
}


harness void main(int x){//find 2^k th root of x
    assume {{expand-points c_e_s.[0] "x"}};
	//k=0; x=1;
	int k=K;
	if(k==0 || x==0) return;
	
	int val = x;
	for(int i=??;condition(i, k);i++){
		if(val != 1 && val != 0){
			val = sqrt(val);
		}
	}
	assert(val !=0);
	assert(val == twokroot(x,k));
}
