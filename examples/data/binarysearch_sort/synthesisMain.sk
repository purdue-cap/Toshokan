pragma options "--bnd-inline-amnt 5 --bnd-inbits 3 --bnd-cbits 3 --slv-nativeints --bnd-unroll-amnt 16";
int N =5;

int cap = {{get-cap-logs (subtree logs "ANONYMOUS::sort_proxy") n_unknowns}};
int logged = {{get-n-logs (subtree logs "ANONYMOUS::sort_proxy")}};
int[cap] i_0_arr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sort_proxy") 0 n_unknowns}} };
int[cap] i_1_arr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sort_proxy") 1 n_unknowns}} };
int[cap] i_2_arr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sort_proxy") 2 n_unknowns}} };
int[cap] i_3_arr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sort_proxy") 3 n_unknowns}} };
int[cap] i_4_arr = { {{expand-to-arg-array (subtree logs "ANONYMOUS::sort_proxy") 4 n_unknowns}} };
int[cap] r_0_arr = { {{expand-to-ith-rtn-array (subtree logs "ANONYMOUS::sort_proxy") 0 n_unknowns}} };
int[cap] r_1_arr = { {{expand-to-ith-rtn-array (subtree logs "ANONYMOUS::sort_proxy") 1 n_unknowns}} };
int[cap] r_2_arr = { {{expand-to-ith-rtn-array (subtree logs "ANONYMOUS::sort_proxy") 2 n_unknowns}} };
int[cap] r_3_arr = { {{expand-to-ith-rtn-array (subtree logs "ANONYMOUS::sort_proxy") 3 n_unknowns}} };
int[cap] r_4_arr = { {{expand-to-ith-rtn-array (subtree logs "ANONYMOUS::sort_proxy") 4 n_unknowns}} };


int[{{n_unknowns}}] unknown_0 = ??;
int[{{n_unknowns}}] unknown_1 = ??;
int[{{n_unknowns}}] unknown_2 = ??;
int[{{n_unknowns}}] unknown_3 = ??;
int[{{n_unknowns}}] unknown_4 = ??;
int used_unknown = 0;

int[N] sort(int[N] input){
    return sort_proxy(input[0],input[1],input[2],input[3],input[4]);
}

int[N] sort_proxy(int input_0,int input_1,int input_2,int input_3,int input_4) {
   
	{{#for-cap-logs (subtree logs "ANONYMOUS::sort_proxy") n_unknowns}}
	if ({{@index}} < logged && i_0_arr[{{@index}}] == input_0 && i_1_arr[{{@index}}] == input_1 && i_2_arr[{{@index}}] == input_2 && i_3_arr[{{@index}}] == input_3&& i_4_arr[{{@index}}] == input_4) {
		int[N] ind = {r_0_arr[{{@index}}], r_1_arr[{{@index}}], r_2_arr[{{@index}}], r_3_arr[{{@index}}], r_4_arr[{{@index}}]};
		return ind;
	}
	{{/for-cap-logs}}
	
	assert logged < cap;
   int val_0 = unknown_0[used_unknown];
   int val_1 = unknown_1[used_unknown];
   int val_2 = unknown_2[used_unknown];
   int val_3 = unknown_3[used_unknown];
   int val_4 = unknown_4[used_unknown];
   used_unknown++;
	i_0_arr[logged] = input_0;
	i_1_arr[logged] = input_1;
	i_2_arr[logged] = input_2;
	i_3_arr[logged] = input_3;
	i_4_arr[logged] = input_4;
	r_0_arr[logged] = val_0;
	r_1_arr[logged] = val_1;
	r_2_arr[logged] = val_2;
	r_3_arr[logged] = val_3;
	r_4_arr[logged] = val_4;
	logged ++;
   int[N] ind = {val_0, val_1, val_2, val_3, val_4};
   return ind;
}

int linear_search(int[N] arr,int x){
	for(int i=0;i<N;i++){
		if(arr[i] == x) return i;
	}
	return -1;
}
harness void main(int arr_0,int arr_1,int arr_2,int arr_3,int arr_4,int x){//search for x in arr
    {{expand-x-d-points-to-assume c_e_s "arr_0" "arr_1" "arr_2" "arr_3" "arr_4" "x"}}
    int[N] arr = {arr_0,arr_1,arr_2,arr_3,arr_4};
	int[N] sarr = sort(arr);
	//assert(sarr[0] <= sarr[N-1]);
	int exists = linear_search(sarr,x);
	int imin =0;
	int imax= N - 1;
	int found = -1;
	while (found == -1 && {| (imin | N | imax) ( < | <= | > |>=) (imin | N | imax) |})
	//while (imax >= imin && found == -1)
    {
	  	int imid = (imin + imax)/2;
		if(sarr[imid] <  x){
			if(??)
				imin = {| (imin | N | imax | imid) ( + | -) ?? |};
			else
				imax = {| (imin | N | imax | imid) ( + | -) ?? |};
		}
		else if (sarr[imid] > x){
			if(??)
				imin = {| (imin | N | imax | imid) ( + | -) ?? |};
			else
				imax = {| (imin | N | imax | imid) ( + | -) ?? |};
		}
		else
			found = imid;
			
    }
    if(exists == -1) 
    	assert(found == -1);
	else
		assert(sarr[exists] == sarr[found] && sarr[found] == x);
}